1.
Fazendo um componente interativo 
Vamos preencher o componente Square com um X quando você o clicar. Declare uma função chamada handleClick dentro de Square. Então, adicione onClick às props do elemento JSX button retornado de Square:

  // //1
  // function handleClick() {
  //   console.log('clicou!');
  // }


2.
Como um próximo passo, você quer que o componente Square “lembre-se” de que ele foi clicado, e preenchê-lo com uma marca de “X”. Para “lembrar-se” de coisas, componentes usam state.

O React fornece uma função especial chamada useState a qual você pode chamar a partir de seu componente para permitir que ele “lembre-se” de coisas. Vamos armazenar o valor atual do Square em state, e mudá-lo quando o Square for clicado.

Importe useState no topo do arquivo. Remova a prop value do componente Square. Em vez disso, adicione uma nova linha no começo de Square que chame useState. Faça com que ela retorne uma variável de state chamada value:

value salva o valor e setValue é a função que pode ser usada para mudar esse valor. O null passado para useState é usado como o valor inicial desta variável de state, então aqui value começa sendo igual a null.

Já que o componente Square não mais aceita props, você irá remover a prop value de todos os nove componentes Square criados pelo componente Board:

Array(9).fill(null) cria um array com nove elementos e define cada um deles como null. A chamada useState() ao redor dele declara uma variável de state squares a qual é inicialmente definida àquele array. Cada valor no array corresponde ao valor de um quadrado. Quando você preencher o tabuleiro mais tarde, o array squares se parecerá com isto:

A função handleClick cria uma cópia do array squares (nextSquares) com o método de Array JavaScript slice(). Então, handleClick atualiza o array nextSquares para adicionar X ao primeiro (índice [0]) quadrado.

Chamar a função setSquares permite que o React saiba que o state do componente mudou. Isso irá acionar uma rerrenderização dos componentes que usa o state squares (Board) bem como seus componentes filhos (os componentes Square que fazem parte do tabuleiro).

Quando você estava passando onSquareClick={handleClick}, você passava a função handleClick como uma prop. Você não a chamava! Mas agora você está chamando aquela função imediatamente—perceba os parênteses em handleClick(0)—e é por isso que ela é executada muito cedo. Você não quer chamar handleClick até que o usuário clique!

Você poderia consertar isso criando uma função como handleFirstSquareClick que chama handleClick(0), um função como handleSecondSquareClick que chama handleClick(1), e assim por diante. Você passaria (ao invés de chamar) essas funções como props assim: onSquareClick={handleFirstSquareClick}. Isso resolveria o loop infinito.

Entretanto, definir nove funções diferentes e dar um nome a cada uma delas é muito verboso. Em vez disso, vamos fazer isto:

export default function Board() {
  // ...
  return (
    <>
      <div className="board-row">
        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />
        // ...
  );
}
Perceba a nova sintaxe () =>. Aqui, () => handleClick(0) é uma arrow function, a qual é uma maneira mais curta de definir funções. Quando o quadrado é clicado, o código depois da “flecha” => irá executar, chamando handleClick(0).

Agora você precisa atualizar os outros oito quadrados para chamarem handleClick através das arrow functions que você passa. Certifique-se de que cada argumento para cada chamada de handleClick corresponda ao índice do quadrado correto:

export default function Board() {
  // ...
  return (
    <>
      <div className="board-row">
        <Square value={squares[0]} onSquareClick={() => handleClick(0)} />
        <Square value={squares[1]} onSquareClick={() => handleClick(1)} />
        <Square value={squares[2]} onSquareClick={() => handleClick(2)} />
        /// ...

Armazenando um histórico de movimentos 
Se você tivesse mutado o array squares, implementar viagem no tempo seria muito difícil.

Entretanto, você usou slice() para criar uma nova cópia do array de squares depois de cada movimento, e o tratou como imutável. Isso permitirá que você armazene cada versão passada do array squares e navegue entre os turnos que já aconteceram.

Você armazenará os arrays squares antigos em outro array chamado history, o qual você armazenará como uma nova variável de state. O array de history representa todos os states do tabuleiro, do primeiro ao último movimento, e possui uma forma parecida com isto:

[
  // Antes do primeiro movimento
  [null, null, null, null, null, null, null, null, null],
  // Depois do primeiro movimento
  [null, null, null, null, 'X', null, null, null, null],
  // Depois do segundo movimento
  [null, null, null, null, 'X', null, null, null, 'O'],
  // ...
]

// 07
Elevando state, novamente 
Agora você irá escrever um novo componente de nível do topo Game para exibir uma lista de movimentos passados. É ali que você colocará o state history contendo todo o histórico do jogo.

Colocar o state history no componente Game permitirá que você remova o state squares de seu componente filho Board. Assim como você “elevou state” do componente Square ao componente Board, você agora o elevará de Board ao componente de nível superior Game. Isso dá ao componente Game controle total sobre os dados de Board e permite-o instruir Board a renderizar turnos anteriores a partir de history.

Primeiro, adicione um componente Game com export default. Faça-o renderizar o componente Board e alguma marcação HTML:

// 08
Perceba como [Array(9).fill(null)] é um array com um único item, o qual é em si um array de 9 nulls.

Para renderizar os quadrados do movimento atual, você terá que ler os últimos quadrados do array a partir de history. Você não precisa de useState para isso—você já tem informação o suficiente para calculá-lo durante a renderização:

// 09
 A seguir, crie uma função handlePlay dentro do componente Game a qual será chamada pelo componente Board para atualizar o jogo. Passe xIsNext, currentSquares e handlePlay como props ao componente Board:


// 10
Agora substitua as chamadas a setSquares e setXIsNext em handleClick no componente Board com uma única chamada a sua nova função onPlay para que o componente Game possa atualizar Board quando o usuário clicar em um quadrado:

// 11


// 12


// 13
Por fim, você irá definir a função handleClick dentro do componente Board para atualizar o array squares o qual armazena o state de seu tabuleiro:

// 14
A cada vez que um jogador fizer um movimento, xIsNext (um booleano) será invertido para determinar qual o próximo jogador e o state do jogo será salvo. Você atualizará a função handleClick de Board para inverter o valor de xIsNext:

// 15
Quando você marca um quadrado com um X ou um O você não está primeiro checando para ver se o quadrado já possui um valor X ou O. Você pode consertar isso retornando cedo. Você checará para ver se o quadrado já possui um X ou um O. Se o quadrado já estiver preenchido, você chamará return na função handleClick cedo—antes que ela tente atualizar o state do tabuleiro. 

// 16
 Você chamará 'calculateWinner(squares)' na função handleClick do componente Board para checar se um jogador venceu. Você pode realizar essa checagem ao mesmo tempo em que checa se um usuário clicou em um quadrado que já possui um X ou um O. Nós gostaríamos de retornar cedo em ambos os casos:


 // 17 -  Declarando um vencedor 
  Agora que os jogadores podem trocar de vez, você vai querer exibir quando o jogo for  vencido e não existam mais turnos a fazer. Para fazer isso você adicionará uma função  ajudante chamada calculateWinner a qual recebe um array de 9 quadrados, checa por um   vencedor e retorna 'X', 'O', ou null apropriadamente. Não se preocupe muito com a   função calculateWinner; ela não é específica ao React:

  Esses valores não são aleatórios — eles representam todas as combinações possíveis de vitória no jogo da velha
  Horizontais (3)
  Verticais (3)
  Diagonais (2)

  // 18
  Agora você conectará a prop onSquareClick uma função no componente Board que vocchamará de handleClick. Para conectar a proonSquareClick a handleClick você passará função à prop onSquareClick do primeircomponente Square:

  // 19 - Exibindo movimentos passados 
  Já que você está gravando o histórico do jogo da velha, você agora pode exibir uma lista com os movimentos passados ao jogador.

Elementos React como <button> são objetos comuns do JavaScript; você pode movê-los dentro de sua aplicação. Para renderizar múltiplos items em React, você pode usar um array de elementos React.

Você já tem um array de movimentos history no state, então agora você precisa transformá-lo em um array de elementos React. Em JavaScript, para transformar um array em outro, você pode usar o método de array map:

[1, 2, 3].map((x) => x * 2) // [2, 4, 6]
Você usará map para transformar seu history de movimentos em elementos React representando botões na tela, e 
exibir a lista de botões para “pular” para movimentos anteriores. Vamos usar map sobre history no componente Game:

// 20 - Escolhendo uma key 

        À medida em que você itera sobre o array history dentro da função que você passou ao map, o argumento squares vai a cada elemento de history, e o argumento move vai a cada índice do array: 0, 1, 2, …. (Na maior parte dos casos, você precisaria dos elementos do array em si, mas para renderizar uma lista de movimento você precisará apenas dos índices).

          Para cada movimento no histórico do jogo da velha, você cria um item de lista <li> o qual contém um botão           <button>. O botão tem um manipulador onClick o qual chama a função denominada jumpTo (que você ainda não          implementou).

          Por enquanto, você deve ver uma lista de movimentos que ocorreram no jogo e um erro no console das ferramentas do           desenvolvedor. Vamos discutir o que o error de “key” significa.
Quando você renderiza uma lista, o React salva alguma informação sobre cada item da lista renderizado. Quando você atualiza uma lista, o React precisa determinar o que mudou. Você poderia ter adicionado, removido, reposicionado, ou atualizado os items da lista.

Imagine transicionar de

<li>Alexa: 7 tarefas restantes</li>
<li>Ben: 5 tarefas restantes</li>
para

<li>Ben: 9 tarefas restantes</li>
<li>Claudia: 8 tarefas restantes</li>
<li>Alexa: 5 tarefas restantes</li>
Além das contagens atualizadas, um humano lendo isso provavelmente diria que você trocou os pedidos de Alexa e Ben e inseriu Claudia entre Alexa e Ben. No entanto, React é um programa de computador e não sabe o que você pretende, então você precisa especificar uma propriedade key para cada item da lista para diferenciar cada item da lista de seus irmãos. Se seus dados fossem de um banco de dados, os IDs do banco de dados de Alexa, Ben e Claudia poderiam ser usados como chaves.

<li key={user.id}>
  {user.name}: {user.taskCount} tarefas restantes
</li>
Quando uma lista é rerrenderizada, o React usa a key de cada item da lista e procura nos itens da lista anterior por uma chave que combine. Se a lista atual possui uma key que não existia antes, o React cria um componente. Se na lista atual está faltando uma chave que existia na lista anterior, o React destrói o componente anterior. Se duas chaves são iguais, o componente correspondente é movido.

Keys dizem ao React sobre a identidade de cada componente, o que permite ao React manter o state entre rerrenderizações. Se a key de um componente muda, o componente será destruído e recriado com um novo state.

key é uma propriedade especial e reservada em React. Quando um elemento é criado, o React extrai a propriedade key e a salva diretamente no elemento retornado. Mesmo que a key possa parecer como se fosse passada como uma prop, o React automaticamente usa key para decidir quais componente a atualizar. Não há maneira para que um componente peça qual key seu pai especificou.

É fortemente recomendado que você designe keys apropriadas sempre que estiver construindo listas dinâmicas. Se você não tiver uma key apropriada, você pode considerar a reestruturação de seus dados para que você tenha.

Se nenhuma key é especificada, o React irá reportar um erro e usará o índice do array como key por padrão. Usar o índice do array como key é problemático ao tentar re-ordenar os items de uma lista ou inserindo/removendo items da lista. Passar explicitamente key={i} silencia esses erros mas tem os mesmo problemas que índices de array e não é recomendado na maioria dos casos.

Keys não precisam ser globalmente únicas; elas só precisam ser únicas entre componentes e seus filhos.

// 21 - Implementando viagem no tempo 
No histórico do jogo da velha, cada movimento passado possui um ID único associado com ele: é o número sequencial do movimento. Movimentos nunca serão reordenados, excluídos, ou inseridos no meio, então é seguro usar o índice do movimento como key.

Na função Game, você pode adicionar a key como <li key={move}>, e se você recarregar o jogo renderizado, o erro de “key” do React deveria desaparecer:

// 22
Antes que você possa implementar jumpTo, você precisa que o componente Game acompanhe qual passo o usuário está vendo atualmente. Para fazer isso, defina uma nova variável de state chamada currentMove, definida por padrão como 0:

// 23
A seguir, atualize a função jumpTo dentro de Game para atualizar o currentMove. Você também definirá xIsNext como true se o número para o qual você está mudando currentMove seja par.

// 24
Você agora irá fazer duas mudanças à função handlePlay de Game  em que é chamada quando você clica no quadrado.

Se você “ir de volta no tempo” e então fazer um novo movimento a partir daquele ponto, você só gostará manter o histórico até aquele ponto. Em vez de adicionar nextSquares depois de todos os items (sintaxe espalhada ...) em history, você o adicionará em history.slice(0, currentMove + 1) para que você esteja mantendo apenas aquela porção do histórico antigo.
A cada vez que um movimento seja feito, você precisará atualizar currentMove para apontar à última entrada do histórico.

// 25
Finalmente, você irá modificar o componente Game para renderizar o movimento atualmente selecionado, em vez de sempre renderizar o movimento final:

// 26 - Limpeza final 
Se você olhar para o código bastante atenção, pode perceber que xIsNext === true quando currentMove é par e xIsNext === false quando currentMove é ímpar. Em outras palavras, se você sabe o valor de currentMove, então você sempre pode descobrir o que xIsNext deveria ser.

Não há razão para armazenar ambos em state. De fato, sempre tente evitar state redundante. A simplificação do que você armazena em state reduz bugs e faz do seu código mais fácil de entender. Mude Game para que ele não armazene mais xIsNext como uma variável de state separada e em vez disso a descubra com base em currentMove: